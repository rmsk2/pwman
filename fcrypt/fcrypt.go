package fcrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/json"
	"fmt"
)

// DefaultSaltLength denotes the length of the salt generated by GenKey
var DefaultSaltLength uint = 10

// GenKey derives a session key from a password and a salt value. Both are returned
func GenKey(password *string) (salt []byte, key []byte, err error) {
	salt = make([]byte, DefaultSaltLength)

	_, err = rand.Read(salt)
	if err != nil {
		return nil, nil, fmt.Errorf("Unable to generate salt for key: %v", err)
	}

	key, err = ReGenKey(password, salt)
	if err != nil {
		return nil, nil, fmt.Errorf("Unable to generate key: %v", err)
	}

	return salt, key, nil
}

// ReGenKey regenerates a key from a password and a salt
func ReGenKey(password *string, salt []byte) (key []byte, err error) {
	hash := sha256.New()
	keyBytes := ([]byte)(*password)

	_, err = hash.Write(keyBytes)
	if err != nil {
		return nil, fmt.Errorf("Unable to regenerate key: %v", err)
	}

	_, err = hash.Write(salt)
	if err != nil {
		return nil, fmt.Errorf("Unable to regenerate key: %v", err)
	}

	_, err = hash.Write(keyBytes)
	if err != nil {
		return nil, fmt.Errorf("Unable to regenerate key: %v", err)
	}

	key = hash.Sum(nil)

	return key, nil
}

// PwDataMetaInfo contains the meta information of an encrypted data structure
type PwDataMetaInfo struct {
	Salt  []byte
	Nonce []byte
	Data  []byte
}

func makePWDataMetaInfo() *PwDataMetaInfo {
	return &PwDataMetaInfo{
		Salt:  []byte{},
		Nonce: []byte{},
		Data:  []byte{},
	}
}

// EncryptBytes returns the data bytes in encrypted form
func EncryptBytes(password *string, data []byte) (encryptedBytes []byte, err error) {
	pwData := makePWDataMetaInfo()
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	salt, key, err := GenKey(password)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	nonce := make([]byte, aesGCM.NonceSize())

	_, err = rand.Read(nonce)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	pwData.Salt = salt
	pwData.Nonce = nonce
	pwData.Data = aesGCM.Seal(nil, nonce, data, nil)

	res, err := json.MarshalIndent(pwData, "", "    ")
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based encryption: %v", err)
	}

	return res, nil
}

// DecryptBytes returns the data bytes in decrypted form
func DecryptBytes(password *string, encData []byte) (data []byte, err error) {
	pwData := makePWDataMetaInfo()

	err = json.Unmarshal(encData, pwData)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based decryption: %v", err)
	}

	salt := pwData.Salt
	nonce := pwData.Nonce
	dataEnc := pwData.Data

	key, err := ReGenKey(password, salt)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based decryption: %v", err)
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based decryption: %v", err)
	}

	aesGCM, err := cipher.NewGCMWithNonceSize(block, len(nonce))
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based decryption: %v", err)
	}

	data, err = aesGCM.Open(nil, nonce, dataEnc, nil)
	if err != nil {
		return nil, fmt.Errorf("Unable to perform pw based decryption: %v", err)
	}

	return data, nil
}
